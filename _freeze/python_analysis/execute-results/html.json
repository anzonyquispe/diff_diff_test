{
  "hash": "2813bf30394077e1b7a5792c34e41d5a",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Python Package Analysis\"\n---\n\n\n\n\n# Python Packages for Staggered DiD\n\nThis chapter benchmarks Python packages for difference-in-differences with staggered treatment. Python has fewer native implementations compared to R, but several community packages exist.\n\n## Package Availability Summary\n\n| Method | R Package | Python Package | Status |\n|--------|-----------|----------------|--------|\n| Callaway & Sant'Anna | `did` | `csdid`, `diff_diff` | Available |\n| de Chaisemartin & D'Haultfoeuille | `DIDmultiplegtDYN` | `did_multiplegt_dyn` | Available |\n| Sun & Abraham | `fixest::sunab` | `pyfixest` | Available (partial) |\n| Borusyak, Jaravel & Spiess | `didimputation` | None | **Not available in Python** |\n\n::: {#setup-python .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport time\nimport warnings\nwarnings.filterwarnings('ignore')\n\n# Load the data\ndf = pd.read_csv(\"sim_data.csv\")\n\nprint(f\"Data loaded:\")\nprint(f\"Observations: {len(df):,}\")\nprint(f\"Units: {df['id'].nunique():,}\")\nprint(f\"Periods: {df['year'].nunique()}\")\n\n# Calculate true ATT (from treated observations' true effects)\n# We need to regenerate true effects since CSV doesn't have them\ntreat_cohorts = [0, 2012, 2014, 2016, 2018]\ncohort_effects = {0: 0, 2012: 0.5, 2014: 0.3, 2016: 0.1, 2018: 0.0}\ntau_0 = 1.0\ngamma = 0.1\n\ndf['tau_gt'] = 0.0\nmask = df['treated'] == True\ndf.loc[mask, 'tau_gt'] = (\n    tau_0 +\n    df.loc[mask, 'first_treat'].map(cohort_effects) +\n    gamma * (df.loc[mask, 'year'] - df.loc[mask, 'first_treat'])\n)\n\ntrue_overall_att = df.loc[df['treated'], 'tau_gt'].mean()\nprint(f\"\\nTrue overall ATT: {true_overall_att:.4f}\")\n\n# Store results\nresults = {}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nData loaded:\nObservations: 100,000\nUnits: 10,000\nPeriods: 10\n\nTrue overall ATT: 1.5861\n```\n:::\n:::\n\n\n## 1. Callaway & Sant'Anna (`csdid`)\n\nThe `csdid` package is a Python port of the original R `did` package.\n\n::: {#csdid .cell cache='true' execution_count=2}\n``` {.python .cell-code}\ntry:\n    from csdid.att_gt import ATTgt\n\n    print(\"Running csdid ATTgt()...\")\n    print(\"This may take several minutes with 1M units.\\n\")\n\n    start_time = time.perf_counter()\n\n    att_gt = ATTgt(\n        yname='y',\n        gname='first_treat',\n        idname='id',\n        tname='year',\n        data=df\n    )\n\n    out_csdid = att_gt.fit(est_method='dr')  # doubly robust\n\n    csdid_time = time.perf_counter() - start_time\n\n    print(f\"\\nExecution time: {csdid_time:.2f} seconds\")\n\n    # Aggregate to dynamic effects\n    agg_dynamic = out_csdid.aggte(typec='dynamic', na_rm=True)\n\n    # Extract overall ATT from the aggregation\n    csdid_att = agg_dynamic.summ_attgt().atte['overall_att']\n\n    print(f\"\\nEstimated ATT: {csdid_att:.4f}\" if csdid_att else \"ATT not extracted\")\n    print(f\"True ATT: {true_overall_att:.4f}\")\n\n    results['csdid'] = {\n        'package': 'csdid',\n        'method': 'Callaway & Sant\\'Anna',\n        'time': csdid_time,\n        'att': csdid_att,\n        'output': out_csdid\n    }\n\nexcept ImportError as e:\n    print(\"Package csdid not installed.\")\n    print(\"Install with: pip install csdid\")\n    results['csdid'] = {\n        'package': 'csdid',\n        'method': 'Callaway & Sant\\'Anna',\n        'time': None,\n        'error': str(e)\n    }\nexcept Exception as e:\n    print(f\"Error running csdid: {e}\")\n    results['csdid'] = {\n        'package': 'csdid',\n        'method': 'Callaway & Sant\\'Anna',\n        'time': None,\n        'error': str(e)\n    }\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning csdid ATTgt()...\nThis may take several minutes with 1M units.\n\n\nExecution time: 0.61 seconds\n\n\nOverall summary of ATT's based on event-study/dynamic aggregation:\n   ATT Std. Error [95.0%  Conf. Int.]  \n1.7041     0.0201 1.6647       1.7435 *\n\n\nDynamic Effects:\n    Event time  Estimate  Std. Error  [95.0% Simult.   Conf. Band   \n0           -7    0.0760      0.0493          -0.0207      0.1727   \n1           -6    0.0036      0.0497          -0.0939      0.1010   \n2           -5    0.0034      0.0327          -0.0607      0.0674   \n3           -4   -0.0378      0.0318          -0.1002      0.0245   \n4           -3    0.0141      0.0250          -0.0350      0.0631   \n5           -2   -0.0178      0.0240          -0.0648      0.0292   \n6           -1    0.0108      0.0218          -0.0318      0.0534   \n7            0    1.2330      0.0225           1.1889      1.2771  *\n8            1    1.3592      0.0175           1.3250      1.3934  *\n9            2    1.5132      0.0258           1.4627      1.5637  *\n10           3    1.5721      0.0212           1.5305      1.6137  *\n11           4    1.7740      0.0300           1.7152      1.8329  *\n12           5    1.8917      0.0295           1.8339      1.9496  *\n13           6    2.1220      0.0402           2.0432      2.2008  *\n14           7    2.1674      0.0397           2.0896      2.2453  *\n---\nSignif. codes: `*' confidence band does not cover 0\nControl Group:  Never Treated , \nAnticipation Periods:  0\nEstimation Method:  Doubly Robust\n\n\n\nEstimated ATT: 1.7041\nTrue ATT: 1.5861\n```\n:::\n:::\n\n\n## 2. Alternative CS Implementation (`diff_diff`)\n\nThe `diff_diff` package provides another implementation of Callaway & Sant'Anna.\n\n::: {#diff-diff .cell cache='true' execution_count=3}\n``` {.python .cell-code}\ntry:\n    from diff_diff import CallawaySantAnna\n\n    print(\"Running diff_diff CallawaySantAnna()...\")\n    print()\n\n    cs = CallawaySantAnna()\n\n    start_time = time.perf_counter()\n\n    cs_results = cs.fit(\n        df,\n        outcome='y',\n        unit='id',\n        time='year',\n        first_treat='first_treat',\n        aggregate='event_study'\n    )\n\n    diff_diff_time = time.perf_counter() - start_time\n\n    print(f\"Execution time: {diff_diff_time:.2f} seconds\")\n\n    # Extract ATT from event study\n    if hasattr(cs_results, 'event_study_effects'):\n        post_effects = [v['effect'] for k, v in cs_results.event_study_effects.items()\n                       if k >= 0]\n        diff_diff_att = np.mean(post_effects) if post_effects else None\n    else:\n        diff_diff_att = None\n\n    print(f\"\\nEstimated ATT (post-treatment avg): {diff_diff_att:.4f}\" if diff_diff_att else \"\")\n    print(f\"True ATT: {true_overall_att:.4f}\")\n\n    results['diff_diff'] = {\n        'package': 'diff_diff',\n        'method': 'Callaway & Sant\\'Anna',\n        'time': diff_diff_time,\n        'att': diff_diff_att,\n        'output': cs_results\n    }\n\nexcept ImportError as e:\n    print(\"Package diff_diff not installed.\")\n    print(\"Install with: pip install diff-diff\")\n    results['diff_diff'] = {\n        'package': 'diff_diff',\n        'method': 'Callaway & Sant\\'Anna',\n        'time': None,\n        'error': str(e)\n    }\nexcept Exception as e:\n    print(f\"Error running diff_diff: {e}\")\n    results['diff_diff'] = {\n        'package': 'diff_diff',\n        'method': 'Callaway & Sant\\'Anna',\n        'time': None,\n        'error': str(e)\n    }\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning diff_diff CallawaySantAnna()...\n\nExecution time: 0.05 seconds\n\nEstimated ATT (post-treatment avg): 1.7041\nTrue ATT: 1.5861\n```\n:::\n:::\n\n\n## 3. Sun & Abraham via `pyfixest`\n\nThe `pyfixest` package is a Python port of the R `fixest` package and includes support for Sun & Abraham estimation.\n\n::: {#pyfixest .cell cache='true' execution_count=4}\n``` {.python .cell-code}\ntry:\n    import pyfixest as pf\n\n    print(\"Running pyfixest for Sun & Abraham...\")\n    print()\n\n    # Prepare data for pyfixest\n    df_pf = df.copy()\n    df_pf['cohort'] = df_pf['first_treat'].replace(0, np.inf)  # Never-treated = Inf\n\n    start_time = time.perf_counter()\n\n    # Sun & Abraham estimation\n    # pyfixest uses i() for interaction-weighted estimator\n    try:\n        # Try sunab-style estimation\n        out_pf = pf.feols(\n            \"y ~ sunab(cohort, year) | id + year\",\n            data=df_pf,\n            vcov={'CRV1': 'id'}\n        )\n        pf_time = time.perf_counter() - start_time\n\n        print(f\"Execution time: {pf_time:.2f} seconds\")\n        print(out_pf.summary())\n\n        # Extract ATT\n        pf_att = out_pf.coef().mean()  # Average of event study coefficients\n\n        results['pyfixest'] = {\n            'package': 'pyfixest',\n            'method': 'Sun & Abraham',\n            'time': pf_time,\n            'att': pf_att,\n            'output': out_pf\n        }\n\n    except Exception as e:\n        # Fallback to simple TWFE\n        print(f\"sunab not available in pyfixest, running TWFE: {e}\")\n\n        out_pf = pf.feols(\n            \"y ~ treated | id + year\",\n            data=df_pf,\n            vcov={'CRV1': 'id'}\n        )\n        pf_time = time.perf_counter() - start_time\n\n        print(f\"\\nExecution time (TWFE): {pf_time:.2f} seconds\")\n        print(out_pf.summary())\n\n        results['pyfixest'] = {\n            'package': 'pyfixest',\n            'method': 'TWFE (sunab not available)',\n            'time': pf_time,\n            'att': out_pf.coef()['treated'],\n            'output': out_pf\n        }\n\nexcept ImportError as e:\n    print(\"Package pyfixest not installed.\")\n    print(\"Install with: pip install pyfixest\")\n    results['pyfixest'] = {\n        'package': 'pyfixest',\n        'method': 'Sun & Abraham',\n        'time': None,\n        'error': str(e)\n    }\nexcept Exception as e:\n    print(f\"Error running pyfixest: {e}\")\n    results['pyfixest'] = {\n        'package': 'pyfixest',\n        'method': 'Sun & Abraham',\n        'time': None,\n        'error': str(e)\n    }\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning pyfixest for Sun & Abraham...\n\nsunab not available in pyfixest, running TWFE: Unable to evaluate factor `sunab(cohort, year)`. [NameError: name 'sunab' is not defined]\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nExecution time (TWFE): 5.17 seconds\n###\n\nEstimation:  OLS\nDep. var.: y, Fixed effects: id+year\nInference:  CRV1\nObservations:  100000\n\n| Coefficient   |   Estimate |   Std. Error |   t value |   Pr(>|t|) |   2.5% |   97.5% |\n|:--------------|-----------:|-------------:|----------:|-----------:|-------:|--------:|\n| treated       |      1.324 |        0.012 |   114.788 |      0.000 |  1.302 |   1.347 |\n---\nRMSE: 0.958 R2: 0.668 R2 Within: 0.13 \nNone\n```\n:::\n:::\n\n\n## 4. de Chaisemartin & D'Haultfoeuille (`did_multiplegt_dyn`)\n\nThe `did_multiplegt_dyn` package is a Python port of the original Stata/R command by de Chaisemartin & D'Haultfoeuille.\n\n**Method**: Compares switchers to non-switchers at each period, robust to heterogeneous treatment effects.\n\n::: {#dcdh-python .cell cache='true' execution_count=5}\n``` {.python .cell-code}\nimport polars as pl\nfrom did_multiplegt_dyn import DidMultiplegtDyn\n\nprint(\"Running DidMultiplegtDyn()...\")\nprint(\"Note: This estimator can be computationally intensive.\\n\")\n\n# Convert pandas DataFrame to polars and prepare data\ndf_dcdh = pl.from_pandas(df)\ndf_dcdh = df_dcdh.with_columns([\n    pl.col('treated').cast(pl.Int32).alias('D')\n])\nstart_time = time.perf_counter()\n\ntry:\n    # Create model instance\n    model_dcdh = DidMultiplegtDyn(\n        df=df_dcdh,\n        outcome='y',\n        group='id',\n        time='year',\n        treatment='D',\n        effects=5,\n        placebo=3,\n        cluster='id'\n    )\n\n    # Fit the model\n    model_dcdh.fit()\n\n    dcdh_time = time.perf_counter() - start_time\n\n    # Get summary table\n    dcdh_summary = model_dcdh.summary()\n\n    print(f\"\\nExecution time (10% sample): {dcdh_time:.2f} seconds\")\n    print(f\"Estimated full data time: ~{dcdh_time * 10:.0f} seconds\")\n    print()\n    print(dcdh_summary)\n\n    # Extract Average_Total_Effect from summary table\n    dcdh_att = model_dcdh.result['did_multiplegt_dyn']['ATE']['Estimate'].values[0]\n\n    results['did_multiplegt_dyn'] = {\n        'package': 'did_multiplegt_dyn',\n        'method': 'de Chaisemartin & D\\'Haultfoeuille (10% sample)',\n        'time': dcdh_time,\n        'estimated_full_time': dcdh_time * 10,\n        'att': dcdh_att,\n        'output': dcdh_summary\n    }\n\nexcept Exception as e:\n    print(f\"Error during estimation: {e}\")\n    import traceback\n    traceback.print_exc()\n    results['did_multiplegt_dyn'] = {\n        'package': 'did_multiplegt_dyn',\n        'method': 'de Chaisemartin & D\\'Haultfoeuille',\n        'time': None,\n        'att': None,\n        'error': str(e)\n    }\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning DidMultiplegtDyn()...\nNote: This estimator can be computationally intensive.\n\n               Block  Estimate       SE     LB CI    UB CI       N  Switchers     N.w  Switchers.w\n            Effect_1  1.242962 0.019474  1.204793 1.281131 28044.0     7009.0 28044.0       7009.0\n            Effect_2  1.361619 0.019661  1.323084 1.400153 28044.0     7009.0 28044.0       7009.0\n            Effect_3  1.524482 0.022447  1.480487 1.568477 19045.0     5992.0 19045.0       5992.0\n            Effect_4  1.574469 0.022517  1.530335 1.618602 19045.0     5992.0 19045.0       5992.0\n            Effect_5  1.781573 0.028124  1.726450 1.836696 10945.0     3946.0 10945.0       3946.0\nAverage_Total_Effect  1.464355 0.016578  1.431863 1.496847 72018.0    29948.0 72018.0      29948.0\n           Placebo_1 -0.003321 0.019518 -0.041577 0.034934 28044.0     7009.0 28044.0       7009.0\n           Placebo_2 -0.011834 0.023465 -0.057825 0.034156 18044.0     4991.0 18044.0       4991.0\n           Placebo_3 -0.018693 0.028306 -0.074171 0.036786 10973.0     3974.0 10973.0       3974.0\n\nExecution time (10% sample): 0.65 seconds\nEstimated full data time: ~6 seconds\n\n                  Block  Estimate        SE     LB CI     UB CI        N  \\\n0              Effect_1  1.242962  0.019474  1.204793  1.281131  28044.0   \n1              Effect_2  1.361619  0.019661  1.323084  1.400153  28044.0   \n2              Effect_3  1.524482  0.022447  1.480487  1.568477  19045.0   \n3              Effect_4  1.574469  0.022517  1.530335  1.618602  19045.0   \n4              Effect_5  1.781573  0.028124  1.726450  1.836696  10945.0   \n5  Average_Total_Effect  1.464355  0.016578  1.431863  1.496847  72018.0   \n6             Placebo_1 -0.003321  0.019518 -0.041577  0.034934  28044.0   \n7             Placebo_2 -0.011834  0.023465 -0.057825  0.034156  18044.0   \n8             Placebo_3 -0.018693  0.028306 -0.074171  0.036786  10973.0   \n\n   Switchers      N.w  Switchers.w  \n0     7009.0  28044.0       7009.0  \n1     7009.0  28044.0       7009.0  \n2     5992.0  19045.0       5992.0  \n3     5992.0  19045.0       5992.0  \n4     3946.0  10945.0       3946.0  \n5    29948.0  72018.0      29948.0  \n6     7009.0  28044.0       7009.0  \n7     4991.0  18044.0       4991.0  \n8     3974.0  10973.0       3974.0  \n```\n:::\n:::\n\n\n## 5. Borusyak, Jaravel & Spiess (Imputation)\n\n::: {.callout-warning}\n## Not Available in Python\n\nThere is **no native Python package** implementing the imputation estimator from Borusyak, Jaravel & Spiess. This method is only available in:\n\n- **R**: `didimputation` package\n- **Stata**: `did_imputation` command\n\n:::\n\n::: {#imputation-unavailable .cell execution_count=6}\n``` {.python .cell-code}\nprint(\"=\" * 60)\nprint(\"Borusyak, Jaravel & Spiess (did_imputation)\")\nprint(\"=\" * 60)\nprint()\nprint(\"STATUS: NOT AVAILABLE IN PYTHON\")\nprint()\nprint(\"This estimator is only available in:\")\nprint(\"  - R: didimputation package\")\nprint(\"  - Stata: did_imputation command\")\nprint()\n\nresults['didimputation'] = {\n    'package': 'N/A',\n    'method': 'Borusyak, Jaravel & Spiess',\n    'time': None,\n    'att': None,\n    'error': 'No Python implementation available'\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n============================================================\nBorusyak, Jaravel & Spiess (did_imputation)\n============================================================\n\nSTATUS: NOT AVAILABLE IN PYTHON\n\nThis estimator is only available in:\n  - R: didimputation package\n  - Stata: did_imputation command\n\n```\n:::\n:::\n\n\n## 6. Traditional TWFE (Biased Baseline)\n\nFor comparison, let's run traditional TWFE using `linearmodels` or `statsmodels`:\n\n::: {#twfe-python .cell cache='true' execution_count=7}\n``` {.python .cell-code}\ntry:\n    from linearmodels.panel import PanelOLS\n\n    print(\"Running traditional TWFE with linearmodels...\")\n    print()\n\n    # Prepare panel data structure\n    df_panel = df.set_index(['id', 'year'])\n\n    start_time = time.perf_counter()\n\n    model = PanelOLS(\n        df_panel['y'],\n        df_panel[['treated']].astype(float),\n        entity_effects=True,\n        time_effects=True\n    )\n    out_twfe = model.fit(cov_type='clustered', cluster_entity=True)\n\n    twfe_time = time.perf_counter() - start_time\n\n    print(f\"Execution time: {twfe_time:.2f} seconds\")\n    print(out_twfe.summary.tables[1])\n\n    twfe_att = out_twfe.params['treated']\n    print(f\"\\nTWFE ATT estimate: {twfe_att:.4f}\")\n    print(f\"True ATT: {true_overall_att:.4f}\")\n    print(f\"Bias: {twfe_att - true_overall_att:.4f}\")\n\n    results['twfe_linearmodels'] = {\n        'package': 'linearmodels',\n        'method': 'Traditional TWFE (biased)',\n        'time': twfe_time,\n        'att': twfe_att,\n        'output': out_twfe\n    }\n\nexcept ImportError:\n    print(\"Package linearmodels not installed.\")\n    print(\"Install with: pip install linearmodels\")\n\n    # Fallback to statsmodels\n    try:\n        import statsmodels.api as sm\n        from statsmodels.regression.linear_model import OLS\n\n        print(\"\\nRunning TWFE with statsmodels (demeaned)...\")\n\n        # Demean for fixed effects\n        df_fe = df.copy()\n        df_fe['y_demeaned'] = df_fe.groupby('id')['y'].transform(lambda x: x - x.mean())\n        df_fe['y_demeaned'] = df_fe.groupby('year')['y_demeaned'].transform(lambda x: x - x.mean())\n        df_fe['treated_demeaned'] = df_fe.groupby('id')['treated'].transform(lambda x: x - x.mean())\n        df_fe['treated_demeaned'] = df_fe.groupby('year')['treated_demeaned'].transform(lambda x: x - x.mean())\n\n        start_time = time.perf_counter()\n        model = OLS(df_fe['y_demeaned'], df_fe['treated_demeaned']).fit()\n        twfe_time = time.perf_counter() - start_time\n\n        print(f\"Execution time: {twfe_time:.2f} seconds\")\n        print(f\"TWFE ATT: {model.params[0]:.4f}\")\n\n        results['twfe_statsmodels'] = {\n            'package': 'statsmodels',\n            'method': 'Traditional TWFE (biased)',\n            'time': twfe_time,\n            'att': model.params[0]\n        }\n\n    except Exception as e:\n        print(f\"Error: {e}\")\n\nexcept Exception as e:\n    print(f\"Error running TWFE: {e}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning traditional TWFE with linearmodels...\n\nExecution time: 0.09 seconds\n                             Parameter Estimates                              \n==============================================================================\n            Parameter  Std. Err.     T-stat    P-value    Lower CI    Upper CI\n------------------------------------------------------------------------------\ntreated        1.3242     0.0122     108.90     0.0000      1.3003      1.3480\n==============================================================================\n\nTWFE ATT estimate: 1.3242\nTrue ATT: 1.5861\nBias: -0.2620\n```\n:::\n:::\n\n\n## Python Results Summary\n\n::: {#python-summary .cell execution_count=8}\n``` {.python .cell-code}\nimport pandas as pd\n\n# Create summary table\nsummary_data = []\nfor name, r in results.items():\n    summary_data.append({\n        'Package': r.get('package', 'N/A'),\n        'Method': r.get('method', 'N/A'),\n        'Time (s)': r.get('time'),\n        'ATT': r.get('att'),\n        'True ATT': true_overall_att if r.get('time') else None,\n        'Bias': (r.get('att') - true_overall_att) if r.get('att') else None,\n        'Status': 'Error: ' + r.get('error', '') if r.get('error') else 'OK'\n    })\n\nsummary_df = pd.DataFrame(summary_data)\nprint(\"\\n\" + \"=\" * 80)\nprint(\"PYTHON PACKAGE COMPARISON SUMMARY\")\nprint(\"=\" * 80)\nprint(summary_df.to_string(index=False))\n\n# Save for comparison chapter\nsummary_df.to_csv(\"python_results.csv\", index=False)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n================================================================================\nPYTHON PACKAGE COMPARISON SUMMARY\n================================================================================\n           Package                                         Method  Time (s)      ATT  True ATT      Bias                                    Status\n             csdid                           Callaway & Sant'Anna  0.607066 1.704085  1.586146  0.117939                                        OK\n         diff_diff                           Callaway & Sant'Anna  0.049023 1.704085  1.586146  0.117939                                        OK\n          pyfixest                     TWFE (sunab not available)  5.165600 1.324159  1.586146 -0.261987                                        OK\ndid_multiplegt_dyn de Chaisemartin & D'Haultfoeuille (10% sample)  0.645394 1.464355  1.586146 -0.121791                                        OK\n               N/A                     Borusyak, Jaravel & Spiess       NaN      NaN       NaN       NaN Error: No Python implementation available\n      linearmodels                      Traditional TWFE (biased)  0.087213 1.324159  1.586146 -0.261987                                        OK\n```\n:::\n:::\n\n\n::: {#cell-python-timing-plot .cell execution_count=9}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\n# Filter to packages with valid times\ntiming_data = [(r['package'], r['time']) for r in results.values()\n               if r.get('time') is not None]\n\nif timing_data:\n    packages, times = zip(*timing_data)\n\n    fig, ax = plt.subplots(figsize=(10, 6))\n    bars = ax.barh(packages, times, color='steelblue')\n    ax.set_xlabel('Execution Time (seconds)')\n    ax.set_title(f'Python Package Execution Times\\nDataset: {len(df):,} observations')\n\n    # Add time labels\n    for bar, t in zip(bars, times):\n        ax.text(bar.get_width() + 1, bar.get_y() + bar.get_height()/2,\n                f'{t:.1f}s', va='center')\n\n    plt.tight_layout()\n    plt.show()\nelse:\n    print(\"No timing data available to plot.\")\n```\n\n::: {.cell-output .cell-output-display}\n![Execution time comparison (Python packages)](python_analysis_files/figure-html/python-timing-plot-output-1.png){#python-timing-plot}\n:::\n:::\n\n\n## Python Package Availability Notes\n\n### Available Packages\n\n1. **`csdid`**: Full implementation of Callaway & Sant'Anna\n   - Install: `pip install csdid`\n   - Supports doubly-robust estimation\n   - Can be slow with very large datasets\n\n2. **`diff_diff`**: Alternative CS implementation\n   - Install: `pip install diff-diff`\n   - Generally faster than `csdid`\n   - Good for event study aggregation\n\n3. **`pyfixest`**: Port of R's fixest\n   - Install: `pip install pyfixest`\n   - Fast fixed effects estimation\n   - Sun & Abraham support varies by version\n\n4. **`did_multiplegt_dyn`**: de Chaisemartin & D'Haultfoeuille\n   - Install: `pip install did-multiplegt-dyn`\n   - Python port of the R/Stata command\n   - Computationally intensive for large datasets\n\n### Not Available in Python\n\n::: {.callout-important}\n## Missing Python Implementation\n\nThe following estimator does **not have a native Python package**:\n\n**Borusyak, Jaravel & Spiess** (`didimputation`)\n   - Only available in R and Stata\n   - No community Python port exists\n\nFor this method, users must either:\n\n- Use R (recommended via Quarto or rpy2)\n- Use Stata\n- Implement the method from scratch\n:::\n\n",
    "supporting": [
      "python_analysis_files"
    ],
    "filters": [],
    "includes": {}
  }
}